### 阿里云开放平台 3.5 一面（过）

#### 问题

- 面试官介绍部门。

- 自我介绍。

- 询问比赛含金量（学校区域赛参与队伍数、你负责的方面、贡献程度）。

- 项目：
  - 介绍项目。
  - 技术点（多线程）。
  - 多线程如何合作（问项目）。
  - 多线程通信方式。
  - 锁的种类。
  - 各种锁的机制。
  - 多线程和多进程的区别。
  - 线程切换和进程切换的过程和区别。
  - 如何权衡使用多线程还是多进程。

- 宏定义、内联函数和普通函数的区别。

- 函数调用的过程。

- 列举 C++11 的特性。

- 询问 MySQL 使用场景。

- 写题：反转链表（白板，从零开始写头文件、链表节点定义和创建、输入输出）。

- 你还有什么问题问我？

#### 复盘

- 多线程通信方式：
  - 锁：互斥锁、条件锁、自旋锁、读写锁。
  - 信号量：无名线程信号量和命名线程信号量。
  - 信号。
- 锁的种类：
  - 互斥锁（mutex）：一方获得锁，另一方不能获得。（sleep-waiting）
  - 条件锁（condition variable）：条件变量，条件满足则以信号量的方式唤醒阻塞线程。
  - 自旋锁（spinlock）：占用 cpu ，自旋直到获得锁。（busy-waiting）
  - 读写锁（read-write lock）：可同时写。

- 多线程和多进程的区别：

  | 对比维度       | 多进程                                              | 多线程                                 |
  | -------------- | --------------------------------------------------- | -------------------------------------- |
  | 数据共享、同步 | 数据共享复杂，需要用 IPC ；数据是分开的，同步简单。 | 共享进程数据，数据共享简单，同步复杂。 |
  | 内存、CPU      | 占用内存多，切换复杂，CPU 利用率低。                | 占用内存少，切换简单，CPU 利用率高。   |
  | 创建销毁、切换 | 创建销毁、切换复杂，速度慢。                        | 创建销毁、切换简单，速度快。           |
  | 编程、调试     | 编程简单、调试简单。                                | 编程复杂、调试复杂。                   |
  | 可靠性         | 进程间不会相互影响。                                | 一个线程挂掉导致整个进程挂掉。         |
  | 分布式         | 适应于多核、多机分布式。                            | 适应于多核分布式。                     |

- 线程切换和进程切换的过程和区别：
  - 进程切换需要切换虚拟地址空间，而线程不用（共享进程的虚拟地址空间）。
  - 都需要保存现场：栈、程序计数器、通用目的寄存器。
  - 上下文切换的主要开销：保存寄存器内容、CPU 高速缓存失效、 TLB 失效。
- 如何权衡使用多线程还是多进程：
  - 频繁创建销毁、频繁上下文切换的优先使用线程，如 Web 服务器，一个连接一个线程。
  - 多进程鲁棒性强、易调试。
  - 任务类型强相关可考虑用多线程。

- 宏定义、内联函数和普通函数的区别：
  - 宏定义在预处理时期以字符串形式展开，占用编译时间；函数的参数有数据类型、占用内存。
  - 内联函数将一些简单的函数的函数体在主调函数中展开，增加了编译后的代码量，减少函数调用开销。
- 函数调用过程：
  - 函数调用：参数实例化、保存下一指令，并跳转到被调函数。
  - 子函数执行。
  - 恢复现场：释放子函数在栈中变量，返回值。

- 列举 C++11 特性：
  - auto 、nullptr 、for 范围遍历。
  - std::array 、std::forward_list 、std::unordered_map 、std::unordered_set 。
  - std::thread 。
  - std::shared_ptr 、std::weak_ptr 、std::unique_ptr 。
  - std::function 、std::bind 、lambda 表达式。
  - 右值引用、可变长参数模板。
  - 还有很多。

- 反转链表：

  ```cpp
  //评测题目: 给定一个用链表存储的数列，如[2, 1, 5, 9]，将其反转后输出，如[9, 5, 1, 2]。
  #include <iostream>
  
  struct ListNode {
    int val;
    ListNode *next;
    ListNode(int val, ListNode *next = nullptr) : val(val), next(next) {}
  };
  
  ListNode *reverse(ListNode *head) {
    ListNode *p1 = nullptr, *p2 = head;
    while (p2) {
      ListNode *t = p2->next;
      p2->next = p1;
      p1 = p2;
      p2 = t;
    }
    return p1;
  }
  
  void print(ListNode *p) {
    while (p) {
      std::cout << p->val << " "; 
      p = p->next;
    }
    std::cout << std::endl;
  }
  
  int main() {
    const int arr[] = {2, 1, 5, 9};
    const int n = 4;
    ListNode *head = new ListNode(arr[0]);
    ListNode *p = head;
    for (int i = 1; i < n; ++i) {
      p->next = new ListNode(arr[i]);
      p = p->next;
    }
    print(head);
    head = reverse(head);
    print(head);
    return 0;
  }
  ```

  